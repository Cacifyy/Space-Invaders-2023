/*
Author: Joel van Egmond
Date: 4 FEB 2017

Program purpose: Converts a c array bitmap of bytes to either words or longs.

Details:         Input format must be similar to example file.
				 Rules: - array must be the first thing in the file
				- a new line must start after the '{' symbol
				- there must be a space between every element
				- elements must be of the form '0xff' where f is any valid hex character
				- there must be a newline or space before the "};" terminator

Warning:		Aside from checking if you opened a real file this program does
				NO ERROR DETECTION so if you use it something other than what it
				was designed for it may fuck up horribly.
*/

#include <iostream>
#include <fstream>
#include <string>
using namespace std;

void readAndConvert(ifstream &infile, ofstream &outfile, int type, int tokensPerRow);


int main()
{
	ifstream infile;
	ofstream outfile;
	string inFileName;
	string outFileName;
	bool validOutputFormat;
	int tokensPerRow = 0;
	int outputType;

	cout << "Enter name of data file: ";
	cin >> inFileName;
	infile.open(inFileName.c_str());
	if (infile.fail())
	{
		cout << "Error: Failed to open data file - terminating program." << endl;
	}
	else
	{
		validOutputFormat = false;

		while (!validOutputFormat)
		{
			cout << "Convert to word or long?" << endl <<
				"(1 for word, 2 for long): ";

			cin >> outputType;

			if (outputType == 1 || outputType == 2)
			{
				validOutputFormat = true;
			}
		}

		while (tokensPerRow <= 0)
		{
			cout << "Enter number of elements per row: ";
			cin >> tokensPerRow;
		}



		outFileName = "2_" + inFileName;
		outfile.open(outFileName.c_str());
		if (outfile.fail())
		{
			cout << "Error: failed to create output file." << endl;
		}
		else
		{
			readAndConvert(infile, outfile, outputType, tokensPerRow);
			outfile.close();

			cout << "Conversion complete!" << endl
				<< "File " << '"' << outFileName << '"' << " generated." << endl;
		}

		infile.close();
	}

	return 0;
}


void readAndConvert(ifstream &infile, ofstream &outfile, int type, int tokensPerRow)
{
	string parseToken;
	bool reachedStart = false;
	int parseCounter = 1;
	int tokensOnRow = 0;
	int bytesPerElement;

	if (type == 1)
	{
		bytesPerElement = 2;
	}
	else
	{
		bytesPerElement = 4;
	}

	outfile << "/* Array generated by Joel's converter */" << endl << endl;

	getline(infile, parseToken);
	if (!parseToken.empty())
	{
		if (parseToken.find('{') != string::npos)
		{
			reachedStart = true;
		}
	}

	while (!infile.eof() && !reachedStart)
	{
		getline(infile, parseToken);
		if (!parseToken.empty())
		{
			if (parseToken.find('{') != string::npos)
			{
				reachedStart = true;
			}
		}
	}

	if (type == 1)
	{
		outfile << "unsigned int array [] = {" << endl;
	}
	else
	{
		outfile << "unsigned long array [] = {" << endl;
	}
	outfile << '\t';

	infile >> parseToken;
	while (parseToken != "};" && !infile.eof())
	{
		if (parseCounter == 1)
		{
			parseToken.erase(4, 1);
			parseCounter++;
		}
		else if (parseCounter == bytesPerElement)
		{
			tokensOnRow++;

			parseToken.erase(0, 2);
			parseToken += ' ';

			if (tokensOnRow == tokensPerRow)
			{
				parseToken += '\n';
				parseToken += '\t';
				tokensOnRow = 0;
			}

			parseCounter = 1;
		}
		else
		{
			parseToken.erase(4, 1);
			parseToken.erase(0, 2);
			parseCounter++;
		}

		outfile << parseToken;
		infile >> parseToken;

	}

	outfile << '\n' << parseToken << endl;

	return;
}
